'use strict';

var ansi = require('./ansi');

class ConsoleLogger {
  loggerOptions;
  name;
  level;
  _enabled;
  _levels = {
    error: 100,
    warn: 200,
    info: 300,
    debug: 400,
    trace: 500
  };
  _colors = {
    error: ansi.ANSI.ForegroundRed,
    warn: ansi.ANSI.ForegroundYellow,
    info: ansi.ANSI.ForegroundCyan,
    debug: ansi.ANSI.ForegroundMagenta,
    trace: ansi.ANSI.BackgroundBlue
  };
  constructor(name, options) {
    this.name = name;
    const env = typeof process === "undefined" ? void 0 : process.env;
    const logNamePattern = env?.LOG || options?.pattern || "*";
    this._enabled = parseMagicExpr(logNamePattern).test(name);
    this.level = parseLogLevel(env?.LOG_LEVEL) || options?.level || "info";
    this.loggerOptions = options ?? {
      level: this.level,
      pattern: logNamePattern
    };
  }
  error(...msg) {
    this.log("error", ...msg);
  }
  warn(...msg) {
    this.log("warn", ...msg);
  }
  info(...msg) {
    this.log("info", ...msg);
  }
  debug(...msg) {
    this.log("debug", ...msg);
  }
  trace(...msg) {
    this.log("trace", ...msg);
  }
  log(level, ...msg) {
    if (!this._enabled) {
      return;
    }
    if (this._levels[level] > this._levels[this.level]) {
      return;
    }
    const prefix = [this._colors[level], ansi.ANSI.Bold, `[${level.toUpperCase()}]`];
    const name = [this.name, ansi.ANSI.ForegroundReset, ansi.ANSI.BoldReset];
    for (const m of msg) {
      let text = new String(m);
      if (typeof m === "object") {
        text = JSON.stringify(m, null, 2);
      }
      for (const line of text.split("\n")) {
        console[level](prefix.join(""), name.join(""), line);
      }
    }
  }
  child(name, overrideOptions) {
    const mergedPattern = mergePatterns(
      this.loggerOptions.pattern,
      overrideOptions?.pattern
    );
    return new ConsoleLogger(`${this.name}/${name}`, {
      ...this.loggerOptions,
      ...overrideOptions,
      pattern: mergedPattern
    });
  }
}
function parsePatternString(pattern) {
  const patterns = pattern.split(",").map((p) => p.trim());
  const inclusions = [];
  const exclusions = [];
  for (const p of patterns) {
    if (p.startsWith("-")) {
      exclusions.push(p.substring(1));
    } else {
      inclusions.push(p);
    }
  }
  return { inclusions, exclusions };
}
function parseMagicExpr(pattern) {
  const { inclusions: inclusionPatterns, exclusions: exclusionPatterns } = parsePatternString(pattern);
  const inclusions = inclusionPatterns.map((p) => patternToRegex(p));
  const exclusions = exclusionPatterns.map((p) => patternToRegex(p));
  if (inclusions.length === 0 && exclusions.length > 0) {
    inclusions.push(/.*/);
  }
  return {
    test: (name) => {
      const matchesInclusion = inclusions.some((regex) => regex.test(name));
      if (!matchesInclusion) return false;
      const matchesExclusion = exclusions.some((regex) => regex.test(name));
      return !matchesExclusion;
    }
  };
}
function patternToRegex(pattern) {
  let res = "";
  const parts = pattern.split("*");
  for (let i = 0; i < parts.length; i++) {
    if (i > 0) {
      res += ".*";
    }
    res += parts[i];
  }
  return new RegExp(res);
}
function mergePatterns(parentPattern, childPattern) {
  if (!parentPattern && !childPattern) {
    return "*";
  }
  if (!parentPattern) {
    return childPattern;
  }
  if (!childPattern) {
    return parentPattern;
  }
  const parent = parsePatternString(parentPattern);
  const child = parsePatternString(childPattern);
  let allInclusions = [.../* @__PURE__ */ new Set([...parent.inclusions, ...child.inclusions])];
  if (allInclusions.length === 0) {
    allInclusions = ["*"];
  }
  const optimizedInclusions = allInclusions.includes("*") ? ["*"] : allInclusions;
  const allExclusions = [.../* @__PURE__ */ new Set([...parent.exclusions, ...child.exclusions])];
  const inclusionStrings = optimizedInclusions;
  const exclusionStrings = allExclusions.map((e) => "-" + e);
  const allPatterns = [...inclusionStrings, ...exclusionStrings];
  return allPatterns.join(",");
}
function parseLogLevel(level) {
  const value = level?.toLowerCase();
  switch (value) {
    case "error":
    case "warn":
    case "info":
    case "debug":
    case "trace":
      return value;
    default:
      return void 0;
  }
}

exports.ConsoleLogger = ConsoleLogger;
//# sourceMappingURL=console.js.map
//# sourceMappingURL=console.js.map